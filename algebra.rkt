#lang racket


(require "generic.rkt")
(require "generic-arith.rkt")
(require "metric-defs.rkt")

(require (for-syntax syntax/parse))

(provide (all-defined-out))

;; An Algebra is a class that represents the capabilities of elements
;; of a algebraic structure.
;;
;; It provides an interface for
#|
Promoting elements of another algebra to this one.

a predicate that determines whether something is an element of the algebra
accessing relevant data of the algebraic elements

the operations on the algebraic elements

Internally, an algebra represents its elements with a struct defined in the class body.
This enables us to have algebras whose operations are identical in functionality, but whose
elements are distinct.
|#

;; The algebraic structures we are interested are defined on elements of X with
;; the following interface
(define field<%>
  (interface ()
    ;; -> X
    ;; returns the zero-like additive identity of the algebra
    zero-element
    ;; -> X
    ;; returns the one-like multiplicative identity of the algebra
    one-element
    ;; Addition, Subtraction, Multiplication, and Division
    ))



(define real-numbers%
  (class* object% (field<%>)
    (super-new)
    (define/public (zero-element)
      0.0)
    (define/public (one-element)
      1.0)))

;; An AlgebraicOperation is a function
;;
;; [A : Algebra]  (Element-of A)+ -> (Element-of A)
;;
;; that takes a number of elements of an algebra and returns an
;; element of the same algebra. It may have an identity or inverse
;; element. If defined,
;;
;; op-id-el : (Element-of A)
;; is an element of the algebra such that
;; (op x op-identity) == x
;;
;; op-inverse : (Element-of A) -> (Element-of A)
;; is a function that returns an element of A such that
;; (op x (op-inverse x)) == op-identity

;; A CayleyTable represents the result of applying an operation of a binary operation
;; to two elements of a group. 
;; 
;;

;; (struct multivector (grades))
;; A Multivector is a structure
;;   (struct Vector-of (Vector-of X))
;; A multivector in a graded algebra generated by an n-dimensional space
;; represents the 2^n coefficients of the graded elements of said algebra.
;;
;; The grades of the multivector are represented by
;;   n List-of X of length 1, 2, ... (n choose i), ... 2, 1
;; Each vector is a vector of coefficients for the grade i elements
;;
;; Interface
;;
;; mv-ref : (Multivector-over X) Integer* -> X
;; make-mv : List-of X -> Multivector-over X
;; 

;; A PromotionRule is a List
;;   (list from-predicate to-predicate conversion)
;; A promotion rule defines a type conversion rule that allows generic operations to
;; promote a "lower type" to a "higher type" without having to specify all of combinations
;; of instance implementations for convertable types.

(define/generic (geo x y))
(define/generic (wedge x y))
(define/generic (contractl x y))
(define/generic (contractr x y))
(define/generic (dot x y))
(define/generic (hest x y))
(define/generic (scalar x y))
;; (define/generic (commutator x y))
;; (define/generic (anticommutator x y))

(define/generic (rev x))
(define/generic (involute x))
(define/generic (conjugate x))

(define/generic (norm x))
(define/generic (generic-exp x))

(define/implementation (norm [x number?]) (abs x))
(define/implementation (generic-exp [x number?]) (exp x))

(define/generic (->number x))

(define (add* . xs) (foldl add (zero-like (first xs)) xs))
(define (sub* . xs) (foldl sub (first xs) (rest xs)))
(define (mul* . xs) (foldl mul (one-like (first xs)) xs))

(define (geo* . xs) (foldl geo (one-like (first xs)) xs))
(define (wedge* . xs) (foldl wedge (one-like (first xs)) xs))


(define geometric-algebra%
  (class object%
    (init-field p q r [base-field (new real-numbers%)])
    (super-new)

    (define base-one (send base-field one-element))
    (define base-zero (send base-field zero-element))
    (define base-neg-one (neg base-one))
    
    ;; A Dim is a NonnegativeInteger
    ;; interpretation: the index of a spatial dimension, starting with 0

    ;;;; Blades

    (define (blade-print blade port mode)
      (when mode (write-string "b[" port))
      (write (blade-coef blade) port)
      (write-string "b" port)
      (display (apply string-append (map number->string (blade-dims blade))) port)
      (when mode (write-string "]" port)))

    (struct blade (coef dims grade)
      #:methods gen:custom-write
      [(define write-proc blade-print)])
    ;; A BasisBlade is a structure
    ;;  (struct Number List-of Dim Integer)
    ;; interpretation: a basis blade is one of the fundamental building blocks of
    ;; geometric algebra. It represents a weighted, oriented graded subspace of the
    ;; generating field.

    ;; Number (List-of Dim) -> Blade
    ;; creates a blade
    (define (make-blade coef dims)
      (blade coef dims (length dims)))

    ;; Number Dim* -> Blade
    ;; a shorthand for creating blades
    (define (b: c . dims)
      (make-blade c dims))

    (define zero-blade (make-blade base-zero '()))
    (define one-blade (make-blade base-one '()))
    (define neg-one-blade (make-blade base-neg-one '()))

    ;; Blade -> Multivector
    ;; converts a blade to a multivector
    (define (blade->multivector b)
      (multivector (list b)))

    ;;;; Multivectors

    (define (multivector-print mv port mode)
      (when mode (write-string "mv[" port))
      (let ([blades (multivector-blades mv)])
        (blade-print (first blades) port #f)
        (for ([b (in-list (rest blades))])
          (write-string " + " port)
          (blade-print b port #f)))
      (when mode (write-string "]" port)))

    (struct multivector (blades)
      #:methods gen:custom-write
      [(define write-proc multivector-print)])
    ;; A Multivector is a structure
    ;;  (struct List-of BasisBlade)
    ;; where blades are ordered by grade and present dimensions
    ;; interpretation: A multivector represents the general structure of a mixed
    ;; grade object in geometric algebra.

    ;; List-of Blade -> Multivector
    ;; creates a multivector with blades in the proper order
    (define (make-multivector blades)
      (if (empty? blades)
          zero-mv
          (multivector (sort-blades (simplify-blades blades)))))

    (define zero-mv (multivector (list zero-blade)))
    (define one-mv (multivector (list one-blade)))

    ;; Multivector -> Bool
    ;; determines if a multivector is a scalar quantity
    (define (mv:is-scalar? mv)
      (let ([blades (multivector-blades mv)])
        (and (empty? (rest blades)) ;; There is only one basis blade
             (empty? (blade-dims (first blades)))))) ;; and it has no dimensions

    ;; Blade+ -> Multivector
    ;; creates a multivector from a series of blades
    (define (mv: . blades)
      (make-multivector blades))

    ;; Multivector -> Number
    ;; converts a scalar multivector to the number
    (define (multivector->scalar mv)
      (if (mv:is-scalar? mv)
          (blade-coef (first (multivector-blades mv)))
          (error 'multivector->scalar "~a is not a scalar multivector" mv)))

    ;; Number -> Multivector
    ;; converts a scalar to a multivector
    (define (scalar->multivector c)
      (multivector (list (make-blade c '()))))

    ;; Multivector -> Multivector
    ;; filters the grades of a multivector
    (define (select-grade mv g)
      (multivector (filter (λ (b) (= g (blade-grade b)))
                           (multivector-blades mv))))

    ;; List-of Blade -> List-of Blade
    ;; sorts a list of blades by length and then by numberic value
    (define (sort-blades blades)
      (define (blade<? l r)
        (let ([l-grade (blade-grade l)]
              [r-grade (blade-grade r)])
          (cond [(= l-grade r-grade)
                 (let loop ([l (blade-dims l)] [r (blade-dims r)])
                   (cond [(empty? l) #f]
                         [(= (first l) (first r)) (loop (rest l) (rest r))]
                         [else (< (first l) (first r))]))]
                [(< l-grade r-grade) #t]
                [else #f])))
      (sort blades blade<?))

    ;; List-of Blade -> List-of Blade
    ;; simplifies a multivector by combining basis elements
    (define (simplify-blades blades)
      ;; Blade Blade -> Bool
      ;; determines if the basis dimensions are the same
      ;; assumption: the dimensions are in canonical order
      (define (same-basis? left right)
        (let ([l-dims (blade-dims left)]
              [r-dims (blade-dims right)])
          (equal? l-dims r-dims)))
      ;; Blade Blade -> Blade
      ;; combines two blades with the same basis elements
      ;; assumption: the blades have the same basis dimensions
      (define (simplify left right)
        (let ([l-coef (blade-coef left)]
              [r-coef (blade-coef right)])
          (make-blade (add l-coef r-coef) (blade-dims left))))
      ;; List-of Blade -> List-of Blade
      ;; filters out the blades that have a zero coefficient
      (define (filter-zero-coef-blades lob)
        (filter (λ (b) (not (g:= (blade-coef b) 0)))
                lob))
      (let outer-loop ([simplified '()] [blades blades])
        (if (empty? blades)
            (if (empty? simplified)
                (list zero-blade)
                (let ([non-zero-blades (filter-zero-coef-blades simplified)])
                  (if (empty? non-zero-blades)
                      (list zero-blade)
                      non-zero-blades)))
            (let inner-loop ([current (first blades)] [passed-blades '()] [rem-blades (rest blades)])
              (if (empty? rem-blades)
                  (outer-loop (cons current simplified)
                              passed-blades)
                  (let ([next-blade (first rem-blades)])
                    (if (same-basis? current next-blade)
                        (inner-loop (simplify current next-blade)
                                    passed-blades
                                    (rest rem-blades))
                        (inner-loop current
                                    (cons next-blade passed-blades)
                                    (rest rem-blades)))))))))


    ;;;; Metric definitions

    (define num-dimensions (+ p q r))

    (define wedge-metric (new diagonal-metric% [p 0] [q 0] [r num-dimensions]
                              [pos-el base-one]
                              [neg-el base-neg-one]
                              [zero-el base-zero]
                              [element-fn (λ (c dims)
                                            (mv: (apply b: c dims)))]))
    
    (define metric (new diagonal-metric% [p p] [q q] [r r]
                        [pos-el base-one]
                        [neg-el base-neg-one]
                        [zero-el base-zero]
                        [element-fn (λ (c dims)
                                      (mv: (apply b: c dims)))]))
    
    ;;;; Blade Operations

    ;; Blade+ -> Multivector
    ;; returns the sum of blades
    (define (b:+ . xs)
      (if (empty? xs)
          (error 'b:+ "No blades passed to +")
          (make-multivector xs)))

    ;; Blade+ -> Multivector
    ;; returns the negation of a blade or
    ;; (first xs) - (sum (rest xs))
    (define b:-
      (case-lambda
        [() (error 'b:- "No blades passed to -")]
        [(x) (make-blade (neg (blade-coef x)) (blade-dims x))]
        [xs (apply b:+ (first xs) (map b:- (rest xs)))]))

    ;; Blade Number -> Blade
    ;; scales a blade's coefficient by c
    (define (b:scale b c)
      (make-blade (mul (blade-coef b) c)
                  (blade-dims b)))

    ;; Blade -> Blade
    ;; computes the versor inverse of a blade
    (define (b:inv b)
      (let ([sqnorm (multivector->scalar (b:geo b (b:reverse b)))])
        (b:scale b (div 1 sqnorm))))

    ;; Blade Blade -> Blade
    ;; multiply x by the inverse of y
    (define (b:/ x y)
      (b:geo x (b:inv y)))

    ;;; Products

    ;; Blade Blade -> Multivector
    ;; computes the wedge product of two basis blades
    (define (b:wedge left right)
      (let* ([l-coef (blade-coef left)]
             [l-dims (blade-dims left)]
             [r-coef (blade-coef right)]
             [r-dims (blade-dims right)]
             [result-blade (metric-lookup wedge-metric l-dims r-dims)])
        (mv:scale result-blade (mul l-coef r-coef))))

    ;; Blade Blade -> Multivector
    ;; computes the geometric product of two basis-blades
    (define (b:geo left right)
      (let* ([l-coef (blade-coef left)]
             [l-dims (blade-dims left)]
             [r-coef (blade-coef right)]
             [r-dims (blade-dims right)]
             [result-mv (metric-lookup metric l-dims r-dims)])
        (mv:scale result-mv (mul l-coef r-coef))))

    ;; Blade Blade -> Multivector
    ;; computes the left contraction of a and b
    (define (b:contractl a b)
      (let ([a-grade (blade-grade a)]
            [b-grade (blade-grade b)])
        (if (<= a-grade b-grade)
            (select-grade (b:geo a b) (- b-grade a-grade))
            zero-mv)))

    ;; Blade Blade -> Multivector
    ;; computes the right contraction of a and b
    (define (b:contractr a b)
      (let ([a-grade (blade-grade a)]
            [b-grade (blade-grade b)])
        (if (>= a-grade b-grade)
            (select-grade (b:geo a b) (- a-grade b-grade))
            zero-mv)))

    ;; Blade Blade -> Multivector
    ;; computes the dot product of two blades
    (define (b:dot a b)
      (let ([a-grade (blade-grade a)]
            [b-grade (blade-grade b)])
        (if (<= a-grade b-grade)
            (b:contractl a b)
            (b:contractr a b))))

    ;; Blade Blade -> Multivector
    ;; computes the Hestenes metric product of a and b
    (define (b:hest a b)
      (let ([a-grade (blade-grade a)]
            [b-grade (blade-grade b)])
        (if (or (= a-grade 0) (= b-grade 0))
            zero-mv
            (b:dot a b))))

    ;; Blade Blade -> Multivector
    ;; computes the scalar product of a and b
    (define (b:scalar a b)
      (select-grade (b:geo a b) 0))

    ;; Blade Blade -> Multivector
    ;; computes the commutator product of a and b
    (define (b:commutator a b)
      (mv:scale (mv:- (b:geo a b)
                      (b:geo b a))
                0.5))

    ;; Blade Blade -> Multivector
    ;; computes the anti-commutator product of a and b
    (define (b:anti-commutator a b)
      (mv:scale (mv:+ (b:geo a b)
                      (b:geo b a))
                0.5))

    ;;; Grade-dependent sign calculations

    ;; Integer -> Number
    ;; returns the multiplier for the reversion of a grade g blade
    (define (reversion-multiplier g)
      (expt -1.0 (* g (- g 1) 0.5)))

    ;; Blade -> Blade
    ;; computes the reversion of a blade
    (define (b:reverse b)
      (b:scale b (reversion-multiplier (blade-grade b))))

    ;; Integer -> Number
    ;; returns the multiplier for the involution of a grade g blade
    (define (involution-multiplier g)
      (expt -1.0 g))

    ;; Blade -> Blade
    ;; returns the involution of a blade
    (define (b:involute b)
      (b:scale b (involution-multiplier (blade-grade b))))

    ;; Integer -> Number
    ;; returns the multiplier for the Clifford conjugation of a grade g blade
    (define (conjugation-multiplier g)
      (expt -1.0 (* g (+ g 1) 0.5)))

    ;; Blade -> Blade
    ;; returns the Clifford conjugate of a blade
    (define (b:conjugate b)
      (b:scale b (conjugation-multiplier (blade-grade b))))


    ;;;; Multivector Operations

    ;; Multivector+ -> Multivector
    ;; returns the sum of left and right
    (define (mv:+ . xs)
      (if (empty? xs)
          (error 'mv:+ "No multivectors passed to +")
          (make-multivector (flatten (map multivector-blades xs)))))

    ;; Multivector+ -> Multivector
    ;; returns either the negation of a single argument or
    ;; (first xs) - (sum (rest xs))
    (define mv:-
      (case-lambda
        [() (error 'mv:- "No multivectors passed to -")]
        [(x) (make-multivector (map b:- (multivector-blades x)))]
        [xs (apply mv:+ (first xs) (map mv:- (rest xs)))]))

    ;; Multivector Number -> Multivector
    ;; scales a multivectors coefficients by c
    (define (mv:scale mv c)
      (multivector (map (curryr b:scale c) (multivector-blades mv))))

    ;; Multivector -> Multivector
    ;; computes the versor inverse of a multivector
    (define (mv:inv mv)
      (let ([sqnorm (multivector->scalar (mv:geo mv (mv:reverse mv)))])
        (mv:scale mv (div 1 sqnorm))))

    ;; Multivector Multivector -> Multivector
    ;; multiply x by the inverse of y
    (define (mv:/ x y)
      (mv:geo x (mv:inv y)))

    ;;; Grade Dependent Computations

    ;; Multivector -> Multivector
    ;; comptues the reverse of the multivector mv
    (define (mv:reverse mv)
      (make-multivector (map b:reverse (multivector-blades mv))))

    ;; Multivector -> Multivector
    ;; comptues the involution of the multivector mv
    (define (mv:involute mv)
      (make-multivector (map b:involute (multivector-blades mv))))

    ;; Multivector -> Multivector
    ;; comptues the conjugate of the multivector mv
    (define (mv:conjugate mv)
      (make-multivector (map b:conjugate (multivector-blades mv))))

    ;; Multivector -> Multivector
    ;; computes the multivector squared norm
    (define (mv:sqnorm A)
      (mv:geo A (mv:reverse A)))

    ;; Multivector -> Number
    ;; computes the norm of a multivector
    (define (mv:norm A)
      (sqrt (multivector->scalar (mv:sqnorm A))))

    ;;; Products

    ;; [Blade Blade -> Multivector] -> [Multivector Multivector -> Multivector]
    ;; lifts a blade product onto multivectors via bilinearity
    (define ((lift-product->multivector op) left right)
      (let ([unsimplified
             (for*/list ([l (in-list (multivector-blades left))]
                         [r (in-list (multivector-blades right))])
               (op l r))])
        (apply mv:+ unsimplified)))

    (define mv:wedge (lift-product->multivector b:wedge))
    (define mv:geo (lift-product->multivector b:geo))
    (define mv:contractl (lift-product->multivector b:contractl))
    (define mv:contractr (lift-product->multivector b:contractr))
    (define mv:dot (lift-product->multivector b:dot))
    (define mv:hest (lift-product->multivector b:hest))
    (define mv:scalar (lift-product->multivector b:scalar))

    ;; Multivector Multivector -> Multivector
    ;; computes the sandwich product of O I O^-1
    (define (mv:sandwich inside outside)
      (mv:geo* outside inside (mv:inv outside)))

    ;; [MV MV -> MV] -> [MV+ -> MV]
    ;; lifts a binary operation to an arbitrary number of operators
    (define ((lift-binary->n-ary op) . xs)
      (foldl op (first xs) (rest xs)))

    (define mv:wedge* (lift-binary->n-ary mv:wedge))
    (define mv:geo* (lift-binary->n-ary mv:geo))
    (define mv:contractl* (lift-binary->n-ary mv:contractl))
    (define mv:contractr* (lift-binary->n-ary mv:contractr))
    (define mv:dot* (lift-binary->n-ary mv:dot))
    (define mv:hest* (lift-binary->n-ary mv:hest))
    (define mv:scalar* (lift-binary->n-ary mv:scalar))

    ;;; Nonlinear Operations

    ;; Multivector -> Multivector
    ;; computes the exponential of a multivector

    ;; (define (mv:exp A)
    ;;   ;; Multivector Number -> Multivector
    ;;   ;; computes the special cases where A^2 is a scalar
    ;;   (define (scalar-square-dispatch A a-sq)
    ;;     (let ([a (sqrt a-sq)])
    ;;       (cond [(< a-sq 0) (mv:+ (scalar->multivector (cos a))
    ;;                               (mv:scale A (div (sin a) a)))]
    ;;             [(> a-sq 0) (mv:+ (scalar->multivector (cosh a))
    ;;                               (mv:scale A (div (sinh a) a)))]
    ;;             [else (mv:+ one-mv A)])))

    ;;   ;; Number -> Integer
    ;;   ;; computes the closest power of 2 not greater than a number
    ;;   (define (closest-power-of-2 x)
    ;;     (let* ([raw-power (log x 2)]
    ;;            [int-power (exact-floor raw-power)])
    ;;       (expt 2 int-power)))

    ;;   ;; Multivector Integer -> Multivector
    ;;   ;; square the multivector n times
    ;;   (define (square-n-times mv n)
    ;;     (if (= n 1)
    ;;         (mv:geo mv mv)
    ;;         (square-n-times (mv:geo mv mv) (sub1 n))))

    ;;   ;; Multivector -> Multivector
    ;;   ;; computes the general case of the exponential
    ;;   (define (general-multivector-exp A)
    ;;     (let*-values ([(approx-norm-scalar) (sqrt (multivector->scalar
    ;;                                                (select-grade (mv:sqnorm A) 0)))]
    ;;                   [(c pwr) (closest-power-of-2 approx-norm-scalar)])
    ;;       (let* ([A/c (mv:scale A (div 1 c))]
    ;;              [term-mult (λ (i) (mv:scale A/c (div 1 (min 1 i))))]
    ;;              [max-order 10])
    ;;         (let loop ([order 1] [last-term one-mv] [sum one-mv])
    ;;           (if (> order max-order)
    ;;               (square-n-times sum pwr)
    ;;               (let ([this-term (mv:geo last-term (term-mult order))])
    ;;                 (loop (add1 order)
    ;;                       this-term
    ;;                       (mv:+ sum this-term))))))))

    ;;   (let ([a-sq (mv:geo A A)])
    ;;     (if (mv:is-scalar? a-sq)
    ;;         (scalar-square-dispatch A (multivector->scalar a-sq))
    ;;         (general-multivector-exp A))))

    ;; Multivector Multivector Int (Int -> Bool) -> Multivector
    ;; computes the taylor series approximation of the exponential function
    (define (taylor-exp A
                        #:initial-x init-x
                        #:max-order [max-order 15]
                        #:sign-fn [sign-fn (λ (_) 1)]
                        #:term-predicate [include-term? (λ (_) #t)])
      (let loop ([order 1] [X^n one-mv] [n! 1] [sum init-x])
        (if (< order max-order)
            (let* ([new-order (add order 1)] ;; Order increases by 1
                   [new-X^n (mul X^n A)] ;; this is X^n
                   [new-n! (mul n! new-order)] ;; this is n!
                   ;; Next term is X^n / n!
                   ;; Add it if it should be included
                   [new-sum (if (include-term? order)
                                (add sum (scale X^n (div (sign-fn order) n!)))
                                sum)])
              (loop new-order new-X^n new-n! new-sum))
            sum)))

    ;; (exp x) = \sum_{n=0}^\infty \frac{1}{n!} x^n
    (define (mv:exp A) (taylor-exp A #:initial-x one-mv))
    ;; (cos x) = \sum_{n=0}^\infty \frac{(-1)^n}{(2n)!} x^{2n}
    (define (mv:cos A) (taylor-exp A
                                   #:initial-x one-mv
                                   #:sign-fn (λ (n) (/ n 2))
                                   #:term-predicate even?))
    ;; (six x) = \sum_{n=0}^\infty \frac{(-1)^n}{(2n+1)!} x^{2n+1}
    (define (mv:sin A) (taylor-exp A
                                   #:initial-x zero-mv
                                   #:sign-fn (λ (n) (/ (- n 1) 2))
                                   #:term-predicate odd?))

    (define (mv:cosh A) (taylor-exp A
                                    #:initial-x one-mv
                                    #:term-predicate even?))
    
    (define (mv:sinh A) (taylor-exp A
                                    #:initial-x zero-mv
                                    #:term-predicate odd?))


    (define pseudoscalar (mv: (b: 1.0 0 1 2 3 4)))
    (define inv-pseudoscalar (mv: (b: -1.0 0 1 2 3 4)))
    
    ;; Multivector Multivector -> Multivector
    ;; compute the dual of a multivector with respect to a pseudoscalar
    (define (mv:dual mv)
      (mv:contractl mv inv-pseudoscalar))

    ;; Multivector Multivector -> Multivector
    ;; unduals a multivector with respect to a pseudoscalar
    (define (mv:undual mv)
      (mv:contractl mv pseudoscalar))

    ;;;; The element creation interface

    ;; make-element : List-of (list Coefficient . BladeDims) -> Multivector
    ;; takes a list of coefficients and blade dimensions  and returns the multivector of the algebra
    (define/public (make-element . blades)
      (apply mv: (map (curry apply b:) blades)))

    (define/public (zero-element) zero-mv)
    (define/public (one-element) one-mv)

    ;; HACK This is only here to get the testing of dual numbers == 0 to work
    ;; TODO generalize this by making a special dual-number algebra class
    ;; MV Number -> Bool
    ;; Tests if the scalar part is equal to a number
    (define (mv:scalar-= x num)
      (let ([x (multivector->scalar (select-grade x 0))])
        (= x num)))

    (define/implementation (g:= [x multivector?] [y number?])
      (mv:scalar-= x y))
    
    ;;;; Implementing the generic method interface

    (define/implementation (zero-like [x multivector?]) (zero-element))
    (define/implementation (one-like [x multivector?]) (one-element))

    (define-syntax (define-binary-op-implementation stx)
      (syntax-parse stx
        [(_ (method-name x y) body ...)
         #'(begin
             (define/implementation (method-name [x multivector?] [y multivector?]) body ...)
             (define/implementation (method-name [x number?] [y multivector?])
               ((lambda (x y) body ...)
                (scalar->multivector x) y))
             (define/implementation (method-name [x multivector?] [y number?])
               ((lambda (x y) body ...)
                x (scalar->multivector y))))]))

    (define-binary-op-implementation (add x y) (mv:+ x y))
    ;; (define/implementation (add [x multivector?] [y multivector?]) (mv:+ x y))
    ;; (define/implementation (add [x number?] [y multivector?])
    ;;   (mv:+ (scalar->multivector x) y))
    ;; (define/implementation (add [x multivector?] [y number?])
    ;;   (mv:+ x (scalar->multivector y)))

    (define-binary-op-implementation (sub x y) (mv:- x y))
    (define-binary-op-implementation (mul x y) (mv:geo x y))
    (define-binary-op-implementation (div x y) (mv:geo x (mv:inv y)))
    (define-binary-op-implementation (ldiv x y) (mv:geo (mv:inv x) y))

    (define/implementation (scale [x multivector?] [c number?]) (mv:scale x c))
    (define/implementation (inverse [x multivector?]) (mv:inv x))
    (define/implementation (neg [x multivector?]) (mv:- x))

    (define-binary-op-implementation (geo x y) (mv:geo x y))
    (define-binary-op-implementation (wedge x y) (mv:wedge x y))
    (define-binary-op-implementation (contractl x y) (mv:contractl x y))
    (define-binary-op-implementation (contractr x y) (mv:contractr x y))
    (define-binary-op-implementation (dot x y) (mv:dot x y))
    (define-binary-op-implementation (hest x y) (mv:hest x y))
    (define-binary-op-implementation (scalar x y) (mv:scalar x y))
    ;; (define-binary-op-implementation (commutator x y) (mv:commutator x y))
    ;; (define-binary-op-implementation (anticommutator x y) (mv:anticommutator x y))
    
    (define/implementation (rev [x multivector?]) (mv:reverse x))
    (define/implementation (involute [x multivector?]) (mv:involute x))
    (define/implementation (conjugate [x multivector?]) (mv:conjugate x))
    
    (define/implementation (norm [x multivector?]) (mv:norm x))
    (define/implementation (g:exp [x multivector?]) (mv:exp x))
    (define/implementation (g:cos [x multivector?]) (mv:cos x))
    (define/implementation (g:sin [x multivector?]) (mv:sin x))
    (define/implementation (g:cosh [x multivector?]) (mv:cosh x))
    (define/implementation (g:sinh [x multivector?]) (mv:sinh x))
    
    
    (define/implementation (->number [x multivector?]) (multivector->scalar x))))

(define-syntax (define-algebra stx)
  (syntax-parse stx 
    [(_ name prefix alg-class args ...)
     #'(begin
         (define name (new alg-class args ...))
         (... (define-syntax (prefix -stx)
                (syntax-parse -stx
                  [(_ (coef dims ...) ...)
                   #'(send name make-element (list coef dims ...) ...)])
                )))]))
